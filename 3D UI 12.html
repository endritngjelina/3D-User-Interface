<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional 3D UI Components Library</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a1a 0%, #003366 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
            color: #f0f0f0;
        }

        #container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 1000;
            font-size: 14px;
            background: rgba(10, 20, 30, 0.85);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(100, 180, 255, 0.3);
            max-width: 320px;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            z-index: 1000;
            background: rgba(10, 20, 30, 0.85);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(100, 180, 255, 0.3);
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        button {
            background: linear-gradient(45deg, #0067b8, #0099bc);
            border: none;
            color: white;
            padding: 10px 16px;
            margin: 3px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Segoe UI', sans-serif;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            min-width: 140px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            background: linear-gradient(45deg, #0078d7, #00b7c3);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #console {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 10, 20, 0.9);
            color: #00ffcc;
            padding: 15px;
            border-radius: 10px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 13px;
            max-height: 200px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 200, 255, 0.2);
        }

        #console-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(0, 200, 255, 0.2);
        }

        #console-title {
            font-weight: bold;
            color: #00ccff;
        }

        #console-actions button {
            padding: 3px 8px;
            font-size: 11px;
            min-width: auto;
            background: rgba(0, 100, 200, 0.4);
        }

        .component-grid {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            width: 80%;
            max-width: 1200px;
            z-index: 500;
        }

        .grid-item {
            background: rgba(20, 40, 60, 0.7);
            border-radius: 12px;
            padding: 15px;
            backdrop-filter: blur(5px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 180, 255, 0.3);
        }

        .grid-item h4 {
            color: #4ecdc4;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(100, 180, 255, 0.2);
        }

        .grid-item p {
            font-size: 13px;
            line-height: 1.5;
            color: #cce6ff;
        }

        #fps-counter {
            position: absolute;
            bottom: 230px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: #00ffcc;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            z-index: 1000;
        }

        .progress-container {
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.3);
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00aaff, #00ffcc);
            width: 65%;
            border-radius: 4px;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .online {
            background: #00ff99;
            box-shadow: 0 0 8px #00ff99;
        }
        
        .offline {
            background: #ff5555;
            box-shadow: 0 0 8px #ff5555;
        }

        .section-title {
            color: #00ccff;
            text-transform: uppercase;
            font-size: 18px;
            margin-top: 30px;
            margin-bottom: 15px;
            text-align: center;
            letter-spacing: 1px;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .feature-item {
            background: rgba(30, 60, 90, 0.5);
            padding: 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
        }

        .feature-item .icon {
            font-size: 20px;
            margin-right: 10px;
            color: #4ecdc4;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui-overlay">
            <h3>üéõÔ∏è Professional 3D UI Components Library</h3>
            <p><span class="status-indicator online"></span> System: <strong>Operational</strong></p>
            
            <div class="progress-container">
                <div class="progress-bar"></div>
            </div>
            
            <div class="section-title">Core Features</div>
            
            <div class="feature-grid">
                <div class="feature-item">
                    <div class="icon">üîÑ</div>
                    <div>Interactive 3D Components</div>
                </div>
                <div class="feature-item">
                    <div class="icon">üß©</div>
                    <div>Modular Architecture</div>
                </div>
                <div class="feature-item">
                    <div class="icon">‚ö°</div>
                    <div>High Performance</div>
                </div>
                <div class="feature-item">
                    <div class="icon">üîí</div>
                    <div>Secure Design</div>
                </div>
            </div>
            
            <p style="margin-top: 15px;"><strong>Controls:</strong></p>
            <p>‚Ä¢ Left-click + drag: Rotate camera</p>
            <p>‚Ä¢ Scroll: Zoom in/out</p>
            <p>‚Ä¢ Right-click + drag: Pan camera</p>
            <p>‚Ä¢ Click: Interact with components</p>
        </div>
        
        <div id="controls">
            <button onclick="demo.addRandomComponent()">‚ûï Add Component</button>
            <button onclick="demo.resetScene()">üîÑ Reset Scene</button>
            <button onclick="demo.toggleAnimation()">üé¨ Toggle Animation</button>
            <button onclick="demo.exportScene()">üíæ Export Scene</button>
            <button onclick="demo.clearConsole()">üóëÔ∏è Clear Console</button>
            <button onclick="demo.toggleParticles()">‚ú® Toggle Particles</button>
        </div>
        
        <div id="console">
            <div id="console-header">
                <div id="console-title">System Console</div>
                <div id="console-actions">
                    <button onclick="demo.clearConsole()">Clear</button>
                </div>
            </div>
            <div id="console-content">
                <div>> Initializing 3D UI Library...</div>
                <div>> Loading components...</div>
                <div>> Scene setup complete</div>
                <div>> Ready for interaction</div>
            </div>
        </div>
        
        <div class="component-grid">
            <div class="grid-item">
                <h4>Component Library</h4>
                <p>‚Ä¢ Buttons: Interactive with hover/click effects</p>
                <p>‚Ä¢ Sliders: Drag to adjust values</p>
                <p>‚Ä¢ Toggles: On/Off state switches</p>
                <p>‚Ä¢ Panels: Container components</p>
                <p>‚Ä¢ Progress Bars: Visual indicators</p>
                <p>‚Ä¢ Radial Menus: Circular selectors</p>
            </div>
            <div class="grid-item">
                <h4>Technical Specs</h4>
                <p>‚Ä¢ Three.js r128</p>
                <p>‚Ä¢ WebGL 2.0 Rendering</p>
                <p>‚Ä¢ 60 FPS Target</p>
                <p>‚Ä¢ Responsive Design</p>
                <p>‚Ä¢ Touch Support</p>
                <p>‚Ä¢ GPU Accelerated</p>
            </div>
            <div class="grid-item">
                <h4>Microsoft Integration</h4>
                <p>‚Ä¢ Azure-ready architecture</p>
                <p>‚Ä¢ .NET compatible API</p>
                <p>‚Ä¢ Power BI visualization support</p>
                <p>‚Ä¢ Teams integration pathway</p>
                <p>‚Ä¢ Windows UI alignment</p>
                <p>‚Ä¢ Enterprise security model</p>
            </div>
        </div>
        
        <div id="fps-counter">FPS: 60</div>
    </div>

    <script>
        // üöÄ ENHANCED 3D UI LIBRARY
        class UI3DLibrary {
            constructor() {
                this.components = new Map();
                this.eventListeners = new Map();
                this.materials = this.initializeMaterials();
                this.geometries = this.initializeGeometries();
                this.font = null;
                this.loadFont();
                this.particleSystem = null;
            }
            
            loadFont() {
                const loader = new THREE.FontLoader();
                loader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json', 
                    (font) => {
                        this.font = font;
                        console.log("Font loaded successfully");
                    },
                    undefined,
                    (error) => {
                        console.error("Font loading error:", error);
                    }
                );
            }

            initializeMaterials() {
                return {
                    button: new THREE.MeshPhongMaterial({ 
                        color: 0x0078d7, 
                        shininess: 50,
                        transparent: true,
                        opacity: 0.95
                    }),
                    buttonHover: new THREE.MeshPhongMaterial({ 
                        color: 0x0099bc, 
                        shininess: 70,
                        transparent: true,
                        opacity: 1.0
                    }),
                    slider: new THREE.MeshPhongMaterial({ 
                        color: 0x6c5ce7, 
                        shininess: 40 
                    }),
                    toggle: new THREE.MeshPhongMaterial({ 
                        color: 0xff7675, 
                        shininess: 40,
                        transparent: true,
                        opacity: 0.9
                    }),
                    panel: new THREE.MeshPhongMaterial({ 
                        color: 0x1e2a38, 
                        transparent: true, 
                        opacity: 0.85,
                        shininess: 20
                    }),
                    text: new THREE.MeshPhongMaterial({ 
                        color: 0xffffff, 
                        shininess: 0 
                    }),
                    progressBar: new THREE.MeshPhongMaterial({
                        color: 0x00aaff,
                        shininess: 30
                    }),
                    progressBackground: new THREE.MeshPhongMaterial({
                        color: 0x2d3436,
                        shininess: 10
                    }),
                    radialMenu: new THREE.MeshPhongMaterial({
                        color: 0x4ecdc4,
                        shininess: 60,
                        transparent: true,
                        opacity: 0.9
                    })
                };
            }

            initializeGeometries() {
                return {
                    buttonBox: new THREE.BoxGeometry(2, 0.5, 0.3),
                    sliderTrack: new THREE.BoxGeometry(3, 0.2, 0.2),
                    sliderHandle: new THREE.SphereGeometry(0.3, 16, 12),
                    toggleBase: new THREE.CylinderGeometry(0.8, 0.8, 0.3, 32),
                    toggleSwitch: new THREE.SphereGeometry(0.4, 16, 12),
                    panel: new THREE.BoxGeometry(4, 3, 0.1),
                    progressBar: new THREE.BoxGeometry(3, 0.4, 0.2),
                    progressBackground: new THREE.BoxGeometry(3, 0.4, 0.1),
                    radialSegment: new THREE.CylinderGeometry(0.1, 0.1, 0.1, 32),
                    radialBase: new THREE.CylinderGeometry(2, 2, 0.2, 32)
                };
            }

            createTextMesh(text, size = 0.2, height = 0.05, color = 0xffffff) {
                if (!this.font) {
                    // Fallback to simple geometry if font not loaded
                    const textGeometry = new THREE.BoxGeometry(size * text.length * 0.3, size, height);
                    const textMesh = new THREE.Mesh(textGeometry, this.materials.text);
                    textMesh.material.color.setHex(color);
                    return textMesh;
                }
                
                const textGeometry = new THREE.TextGeometry(text, {
                    font: this.font,
                    size: size,
                    height: height,
                    curveSegments: 4,
                    bevelThickness: 0.01,
                    bevelSize: 0.01,
                    bevelEnabled: true
                });
                
                textGeometry.computeBoundingBox();
                const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
                
                const textMaterial = this.materials.text.clone();
                textMaterial.color.setHex(color);
                
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.x = centerOffset;
                return textMesh;
            }

            // üîò ENHANCED BUTTON COMPONENT
            createButton(options = {}) {
                const config = {
                    position: { x: 0, y: 0, z: 0 },
                    label: 'Button',
                    onClick: () => console.log('Button clicked'),
                    color: 0x0078d7,
                    width: 2,
                    height: 0.5,
                    ...options
                };

                const group = new THREE.Group();
                
                // Button mesh
                const buttonGeometry = new THREE.BoxGeometry(config.width, config.height, 0.3);
                const buttonMesh = new THREE.Mesh(buttonGeometry, this.materials.button.clone());
                buttonMesh.material.color.setHex(config.color);
                group.add(buttonMesh);

                // Text label
                const textMesh = this.createTextMesh(config.label, 0.15, 0.05);
                textMesh.position.set(0, 0, 0.2);
                group.add(textMesh);

                group.position.set(config.position.x, config.position.y, config.position.z);
                
                // Add interaction
                const component = {
                    group,
                    type: 'button',
                    config,
                    mesh: buttonMesh,
                    text: textMesh,
                    isHovered: false,
                    originalMaterial: buttonMesh.material.clone(),
                    hoverMaterial: this.materials.buttonHover.clone(),
                    setLabel: function(newLabel) {
                        group.remove(this.text);
                        this.text = this.createTextMesh(newLabel, 0.15, 0.05);
                        this.text.position.set(0, 0, 0.2);
                        group.add(this.text);
                    }
                };

                this.components.set(group.uuid, component);
                return component;
            }

            // üìä PROGRESS BAR COMPONENT
            createProgressBar(options = {}) {
                const config = {
                    position: { x: 0, y: 0, z: 0 },
                    value: 50, // percentage
                    width: 3,
                    height: 0.4,
                    color: 0x00aaff,
                    ...options
                };

                const group = new THREE.Group();
                
                // Background
                const bgGeometry = new THREE.BoxGeometry(config.width, config.height, 0.1);
                const bgMesh = new THREE.Mesh(bgGeometry, this.materials.progressBackground);
                group.add(bgMesh);
                
                // Progress
                const progressWidth = (config.value / 100) * config.width;
                const progressGeometry = new THREE.BoxGeometry(progressWidth, config.height * 0.8, 0.2);
                const progressMesh = new THREE.Mesh(progressGeometry, this.materials.progressBar.clone());
                progressMesh.material.color.setHex(config.color);
                progressMesh.position.x = -((config.width - progressWidth) / 2);
                group.add(progressMesh);
                
                // Text label
                const textMesh = this.createTextMesh(`${config.value}%`, 0.15, 0.05);
                textMesh.position.set(0, 0, 0.15);
                group.add(textMesh);

                group.position.set(config.position.x, config.position.y, config.position.z);
                
                const component = {
                    group,
                    type: 'progressBar',
                    config,
                    progressMesh,
                    textMesh,
                    setValue: function(value) {
                        config.value = Math.max(0, Math.min(100, value));
                        const progressWidth = (config.value / 100) * config.width;
                        
                        // Update progress mesh
                        group.remove(this.progressMesh);
                        const newGeometry = new THREE.BoxGeometry(progressWidth, config.height * 0.8, 0.2);
                        this.progressMesh = new THREE.Mesh(newGeometry, this.materials.progressBar.clone());
                        this.progressMesh.material.color.setHex(config.color);
                        this.progressMesh.position.x = -((config.width - progressWidth) / 2);
                        group.add(this.progressMesh);
                        
                        // Update text
                        group.remove(this.textMesh);
                        this.textMesh = this.createTextMesh(`${config.value}%`, 0.15, 0.05);
                        this.textMesh.position.set(0, 0, 0.15);
                        group.add(this.textMesh);
                    }
                };

                this.components.set(group.uuid, component);
                return component;
            }

            // üåÄ RADIAL MENU COMPONENT
            createRadialMenu(options = {}) {
                const config = {
                    position: { x: 0, y: 0, z: 0 },
                    options: ['Option 1', 'Option 2', 'Option 3', 'Option 4'],
                    onSelect: (index) => console.log('Selected option:', index),
                    ...options
                };

                const group = new THREE.Group();
                
                // Base
                const baseMesh = new THREE.Mesh(this.geometries.radialBase, this.materials.radialMenu);
                group.add(baseMesh);
                
                // Options
                const segments = [];
                const radius = 1.5;
                const angleStep = (Math.PI * 2) / config.options.length;
                
                for (let i = 0; i < config.options.length; i++) {
                    const angle = i * angleStep;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    
                    const segmentGroup = new THREE.Group();
                    
                    // Segment
                    const segmentMesh = new THREE.Mesh(this.geometries.radialSegment, this.materials.button.clone());
                    segmentMesh.material.color.setHex(0x4ecdc4);
                    segmentGroup.add(segmentMesh);
                    
                    // Text
                    const textMesh = this.createTextMesh(config.options[i], 0.1, 0.03);
                    textMesh.position.set(0, 0, 0.2);
                    segmentGroup.add(textMesh);
                    
                    segmentGroup.position.set(x, y, 0.1);
                    segmentGroup.rotation.z = angle + Math.PI/2;
                    segmentGroup.userData = { index: i };
                    
                    group.add(segmentGroup);
                    segments.push(segmentGroup);
                }

                group.position.set(config.position.x, config.position.y, config.position.z);
                
                // Center text
                const centerText = this.createTextMesh('Menu', 0.15, 0.05);
                centerText.position.set(0, 0, 0.15);
                group.add(centerText);

                const component = {
                    group,
                    type: 'radialMenu',
                    config,
                    segments,
                    centerText,
                    setOptions: function(options) {
                        // Implementation to update options
                    }
                };

                this.components.set(group.uuid, component);
                return component;
            }

            // üéØ ENHANCED INTERACTION SYSTEM
            setupInteractions(camera, renderer) {
                this.camera = camera;
                this.renderer = renderer;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.isDragging = false;
                this.touchStart = { x: 0, y: 0 };
                this.lastTouchTime = 0;

                // Mouse events
                renderer.domElement.addEventListener('mousemove', (e) => this.onMouseMove(e), false);
                renderer.domElement.addEventListener('click', (e) => this.onClick(e), false);
                renderer.domElement.addEventListener('mousedown', (e) => this.onMouseDown(e), false);
                renderer.domElement.addEventListener('mouseup', (e) => this.onMouseUp(e), false);
                
                // Touch events
                renderer.domElement.addEventListener('touchstart', (e) => this.onTouchStart(e), false);
                renderer.domElement.addEventListener('touchmove', (e) => this.onTouchMove(e), false);
                renderer.domElement.addEventListener('touchend', (e) => this.onTouchEnd(e), false);
            }

            onMouseMove(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                // Handle hover effects
                this.components.forEach(component => {
                    const intersects = this.raycaster.intersectObject(component.group, true);
                    
                    if (intersects.length > 0) {
                        if (!component.isHovered && component.type === 'button') {
                            component.isHovered = true;
                            component.mesh.material = component.hoverMaterial;
                            component.group.scale.set(1.1, 1.1, 1.1);
                        }
                    } else {
                        if (component.isHovered && component.type === 'button') {
                            component.isHovered = false;
                            component.mesh.material = component.originalMaterial;
                            component.group.scale.set(1, 1, 1);
                        }
                    }
                });
            }

            // Touch event handlers
            onTouchStart(event) {
                event.preventDefault();
                if (event.touches.length === 1) {
                    const touch = event.touches[0];
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    this.touchStart.x = touch.clientX;
                    this.touchStart.y = touch.clientY;
                    
                    // Simulate mouse position for interaction
                    this.mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                    this.mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    // Handle as click if within 300ms
                    this.lastTouchTime = Date.now();
                    this.onMouseDown(event);
                }
            }

            onTouchMove(event) {
                event.preventDefault();
                if (event.touches.length === 1) {
                    const touch = event.touches[0];
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    this.mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                    this.mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                    this.onMouseMove(event);
                }
            }

            onTouchEnd(event) {
                event.preventDefault();
                if (Date.now() - this.lastTouchTime < 300) {
                    this.onClick(event);
                }
                this.onMouseUp(event);
            }

            // üé® UTILITY METHODS
            getAllComponents() {
                return Array.from(this.components.values());
            }

            createParticleSystem(count = 2000) {
                const particlesGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                
                for (let i = 0; i < count * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 100;
                    positions[i + 1] = (Math.random() - 0.5) * 100;
                    positions[i + 2] = (Math.random() - 0.5) * 100;
                    
                    colors[i] = Math.random() * 0.5 + 0.5;
                    colors[i + 1] = Math.random() * 0.5 + 0.5;
                    colors[i + 2] = Math.random() * 0.5 + 0.5;
                }
                
                particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const particlesMaterial = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.7,
                    sizeAttenuation: true
                });
                
                this.particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
                return this.particleSystem;
            }
        }

        // üöÄ DEMO APPLICATION
        class UIDemo {
            constructor() {
                this.uiLib = new UI3DLibrary();
                this.animationEnabled = true;
                this.particlesEnabled = true;
                this.lastFrameTime = 0;
                this.fps = 60;
                this.init();
                this.createDemoComponents();
                this.animate();
            }

            init() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 0);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('container').appendChild(this.renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(10, 15, 10);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                const pointLight = new THREE.PointLight(0x4ecdc4, 1.0, 100);
                pointLight.position.set(-10, 10, 10);
                this.scene.add(pointLight);

                // Camera position
                this.camera.position.set(0, 0, 15);
                
                // Camera controls
                this.setupCameraControls();
                
                // Setup interactions
                this.uiLib.setupInteractions(this.camera, this.renderer);
                
                // Add particles
                const particles = this.uiLib.createParticleSystem(3000);
                this.scene.add(particles);
                
                // Resize handler
                window.addEventListener('resize', () => this.onWindowResize(), false);
                
                this.log('üöÄ System initialized');
                this.log('üñ•Ô∏è Three.js v' + THREE.REVISION);
                this.log('üîß Interaction system ready');
            }

            setupCameraControls() {
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };
                let isRightDragging = false;

                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // Left click for object interaction
                        // Handled in library
                    } else if (e.button === 2) { // Right click for camera pan
                        isRightDragging = true;
                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    }
                });

                this.renderer.domElement.addEventListener('mousemove', (e) => {
                    if (isRightDragging) {
                        const deltaMove = {
                            x: e.clientX - previousMousePosition.x,
                            y: e.clientY - previousMousePosition.y
                        };

                        this.camera.position.x -= deltaMove.x * 0.01;
                        this.camera.position.y += deltaMove.y * 0.01;
                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    }
                });

                this.renderer.domElement.addEventListener('mouseup', (e) => {
                    if (e.button === 2) {
                        isRightDragging = false;
                    }
                });

                // Zoom with wheel
                this.renderer.domElement.addEventListener('wheel', (e) => {
                    this.camera.position.z += e.deltaY * 0.01;
                    this.camera.position.z = Math.max(5, Math.min(30, this.camera.position.z));
                });

                // Prevent context menu
                this.renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            createDemoComponents() {
                // Create demo buttons
                const button1 = this.uiLib.createButton({
                    position: { x: -6, y: 3, z: 0 },
                    label: 'Action',
                    color: 0x0078d7,
                    onClick: () => this.log('‚úÖ Action button clicked!')
                });
                this.scene.add(button1.group);

                const button2 = this.uiLib.createButton({
                    position: { x: -6, y: 1.5, z: 0 },
                    label: 'Secondary',
                    color: 0x6c5ce7,
                    onClick: () => this.log('üîÆ Secondary action performed')
                });
                this.scene.add(button2.group);

                // Create sliders
                const slider1 = this.uiLib.createSlider({
                    position: { x: 0, y: 3, z: 0 },
                    min: 0,
                    max: 100,
                    value: 75,
                    onChange: (value) => this.log(`üéöÔ∏è Volume: ${Math.round(value)}%`)
                });
                this.scene.add(slider1.group);

                const slider2 = this.uiLib.createSlider({
                    position: { x: 0, y: 1, z: 0 },
                    min: -50,
                    max: 50,
                    value: 0,
                    onChange: (value) => this.log(`‚öñÔ∏è Balance: ${Math.round(value)}`)
                });
                this.scene.add(slider2.group);

                // Create toggles
                const toggle1 = this.uiLib.createToggle({
                    position: { x: 6, y: 3, z: 0 },
                    isOn: true,
                    onToggle: (state) => this.log(`üîä Audio: ${state ? 'ON' : 'OFF'}`)
                });
                this.scene.add(toggle1.group);

                const toggle2 = this.uiLib.createToggle({
                    position: { x: 6, y: 1, z: 0 },
                    isOn: false,
                    onToggle: (state) => this.log(`üì≥ Vibration: ${state ? 'ON' : 'OFF'}`)
                });
                this.scene.add(toggle2.group);

                // Create panels
                const panel1 = this.uiLib.createPanel({
                    position: { x: -3, y: -2, z: -1 },
                    title: 'Settings Panel'
                });
                this.scene.add(panel1.group);

                const panel2 = this.uiLib.createPanel({
                    position: { x: 3, y: -2, z: -1 },
                    title: 'Info Panel'
                });
                this.scene.add(panel2.group);
                
                // Create progress bar
                const progressBar = this.uiLib.createProgressBar({
                    position: { x: 0, y: -1, z: 0 },
                    value: 65,
                    color: 0x00cc99
                });
                this.scene.add(progressBar.group);
                
                // Create radial menu
                const radialMenu = this.uiLib.createRadialMenu({
                    position: { x: 6, y: -1, z: 0 },
                    options: ['Home', 'Settings', 'Profile', 'Help'],
                    onSelect: (index) => this.log(`üåÄ Selected: ${['Home', 'Settings', 'Profile', 'Help'][index]}`)
                });
                this.scene.add(radialMenu.group);

                this.log('üéØ Demo components created');
                this.log('üëâ Interact with components to test');
            }

            addRandomComponent() {
                const types = ['button', 'slider', 'toggle', 'panel', 'progressBar', 'radialMenu'];
                const type = types[Math.floor(Math.random() * types.length)];
                const x = (Math.random() - 0.5) * 12;
                const y = (Math.random() - 0.5) * 8;
                const z = (Math.random() - 0.5) * 4;

                let component;
                switch (type) {
                    case 'button':
                        component = this.uiLib.createButton({
                            position: { x, y, z },
                            label: 'Random',
                            color: Math.random() * 0xffffff,
                            onClick: () => this.log(`üé≤ Random button clicked!`)
                        });
                        break;
                    case 'slider':
                        component = this.uiLib.createSlider({
                            position: { x, y, z },
                            min: 0,
                            max: 100,
                            value: Math.random() * 100,
                            onChange: (value) => this.log(`üéöÔ∏è Random slider: ${Math.round(value)}`)
                        });
                        break;
                    case 'toggle':
                        component = this.uiLib.createToggle({
                            position: { x, y, z },
                            isOn: Math.random() > 0.5,
                            onToggle: (state) => this.log(`üîÑ Random toggle: ${state ? 'ON' : 'OFF'}`)
                        });
                        break;
                    case 'panel':
                        component = this.uiLib.createPanel({
                            position: { x, y, z },
                            title: 'Random Panel'
                        });
                        break;
                    case 'progressBar':
                        component = this.uiLib.createProgressBar({
                            position: { x, y, z },
                            value: Math.floor(Math.random() * 100),
                            color: Math.random() * 0xffffff
                        });
                        break;
                    case 'radialMenu':
                        component = this.uiLib.createRadialMenu({
                            position: { x, y, z },
                            options: ['A', 'B', 'C', 'D'],
                            onSelect: (index) => this.log(`üåÄ Selected option ${index + 1}`)
                        });
                        break;
                }

                this.scene.add(component.group);
                this.log(`‚ûï Added random ${type} component`);
            }

            resetScene() {
                // Clear all components
                this.uiLib.getAllComponents().forEach(component => {
                    this.scene.remove(component.group);
                });
                this.uiLib.components.clear();
                
                // Recreate demo components
                this.createDemoComponents();
                this.log('üîÑ Scene reset');
            }

            toggleAnimation() {
                this.animationEnabled = !this.animationEnabled;
                this.log(`üé¨ Animation ${this.animationEnabled ? 'enabled' : 'disabled'}`);
            }
            
            toggleParticles() {
                this.particlesEnabled = !this.particlesEnabled;
                this.uiLib.particleSystem.visible = this.particlesEnabled;
                this.log(`‚ú® Particles ${this.particlesEnabled ? 'enabled' : 'disabled'}`);
            }
            
            exportScene() {
                const components = [];
                this.uiLib.getAllComponents().forEach(comp => {
                    components.push({
                        type: comp.type,
                        position: comp.group.position,
                        config: comp.config
                    });
                });
                
                const sceneData = {
                    components: components,
                    timestamp: new Date().toISOString()
                };
                
                const dataStr = JSON.stringify(sceneData, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                
                const exportFileDefaultName = `3d-ui-scene-${new Date().getTime()}.json`;
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
                
                this.log(`üíæ Scene exported as ${exportFileDefaultName}`);
            }
            
            clearConsole() {
                const consoleContent = document.getElementById('console-content');
                consoleContent.innerHTML = '';
                this.log('Console cleared');
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Calculate FPS
                const now = performance.now();
                const delta = now - this.lastFrameTime;
                this.lastFrameTime = now;
                this.fps = Math.round(1000 / delta);
                
                // Update FPS counter
                document.getElementById('fps-counter').textContent = `FPS: ${this.fps}`;
                
                if (this.animationEnabled) {
                    // Animate particles if enabled
                    if (this.uiLib.particleSystem && this.particlesEnabled) {
                        const positions = this.uiLib.particleSystem.geometry.attributes.position.array;
                        for (let i = 0; i < positions.length; i += 3) {
                            positions[i + 1] += 0.01;
                            if (positions[i + 1] > 25) positions[i + 1] = -25;
                        }
                        this.uiLib.particleSystem.geometry.attributes.position.needsUpdate = true;
                    }
                }
                
                this.renderer.render(this.scene, this.camera);
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            log(message) {
                const consoleContent = document.getElementById('console-content');
                const timestamp = new Date().toLocaleTimeString();
                consoleContent.innerHTML += `<div>[${timestamp}] ${message}</div>`;
                consoleContent.scrollTop = consoleContent.scrollHeight;
            }
        }

        // üöÄ INITIALIZE APPLICATION
        const demo = new UIDemo();
        
        // Expose to global scope for controls
        window.demo = demo;
        window.UI3DLibrary = UI3DLibrary;
        
        console.log('üéõÔ∏è Professional 3D UI Components Library loaded successfully!');
        console.log('üìö Usage: const ui = new UI3DLibrary(); const button = ui.createButton({...});');
    </script>
</body>
</html>